{
  "timestamp": "20241229_132625",
  "files_analyzed": 1,
  "files_improved": 1,
  "improvements": [
    {
      "file": "src\\cli.py",
      "issues": [
        {
          "type": "length",
          "message": "Function improve is too long (21 lines)",
          "line": 21,
          "function": "improve",
          "original": "@cli.command()\n@click.argument('file_path', type=click.Path(exists=True))\n@click.option('--config', '-c', type=click.Path(exists=True), default='config/settings.yaml', help='Path to config file')\n@click.option('--output', '-o', type=click.Path(), help='Path to save improvements (default: print to console)')\ndef improve(file_path: str, config: str, output: Optional[str]):\n    \"\"\"Analyze and improve the given Python file\"\"\"\n    try:\n        with open(config, 'r') as f:\n            config_data = yaml.safe_load(f)\n        auto_coder = AutoCoder(config_data)\n        result = asyncio.run(auto_coder.improve_code(Path(file_path)))\n        output_text = format_result(result)\n        if output:\n            Path(output).write_text(output_text)\n            click.echo(f'Improvements saved to {output}')\n        else:\n            click.echo(output_text)\n    except Exception as e:\n        logger.error(f'Error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        },
        {
          "type": "length",
          "message": "Function batch is too long (24 lines)",
          "line": 67,
          "function": "batch",
          "original": "@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        },
        {
          "type": "complexity",
          "message": "Function batch has high complexity (6)",
          "line": 67,
          "function": "batch",
          "original": "@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        },
        {
          "type": "nesting",
          "message": "Function batch has deep nesting (depth: 3)",
          "line": 67,
          "function": "batch",
          "original": "@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        }
      ],
      "improvements": [
        {
          "type": "maintainability",
          "description": "The `improve` function is too long and violates the single responsibility principle. It should be split into smaller, more focused functions.",
          "original": "```python\n@cli.command()\n@click.argument('file_path', type=click.Path(exists=True))\n@click.option('--config', '-c', type=click.Path(exists=True), default='config/settings.yaml', help='Path to config file')\n@click.option('--output', '-o', type=click.Path(), help='Path to save improvements (default: print to console)')\ndef improve(file_path: str, config: str, output: Optional[str]):\n\"\"\"Analyze and improve the given Python file\"\"\"\ntry:\nwith open(config, 'r') as f:\nconfig_data = yaml.safe_load(f)\nauto_coder = AutoCoder(config_data)\nresult = asyncio.run(auto_coder.improve_code(Path(file_path)))\noutput_text = format_result(result)\nif output:\nPath(output).write_text(output_text)\nclick.echo(f'Improvements saved to {output}')\nelse:\nclick.echo(output_text)\nexcept Exception as e:\nlogger.error(f'Error: {e}')\nclick.echo(f'Error: {e}', err=True)\nraise click.Abort()\n```\n",
          "improved": "```python\n@cli.command()\n@click.argument('file_path', type=click.Path(exists=True))\n@click.option('--config', '-c', type=click.Path(exists=True), default='config/settings.yaml', help='Path to config file')\n@click.option('--output', '-o', type=click.Path(), help='Path to save improvements (default: print to console)')\ndef improve(file_path: str, config: str, output: Optional[str]):\n\"\"\"Analyze and improve the given Python file\"\"\"\ntry:\nresult = analyze_and_improve(file_path, config)\noutput_text = format_result(result)\nhandle_output(output, output_text)\nexcept Exception as e:\nhandle_error(e)\n\ndef analyze_and_improve(file_path: str, config: str) -> dict:\nwith open(config, 'r') as f:\nconfig_data = yaml.safe_load(f)\nauto_coder = AutoCoder(config_data)\nreturn asyncio.run(auto_coder.improve_code(Path(file_path)))\n\ndef handle_output(output: Optional[str], output_text: str):\nif output:\nPath(output).write_text(output_text)\nclick.echo(f'Improvements saved to {output}')\nelse:\nclick.echo(output_text)\n\ndef handle_error(e: Exception):\nlogger.error(f'Error: {e}')\nclick.echo(f'Error: {e}', err=True)\nraise click.Abort()\n```\n\n"
        },
        {
          "type": "maintainability",
          "description": "The `batch` function has high complexity and deep nesting, making it harder to understand and maintain. It should be refactored to reduce complexity and nesting.",
          "original": "```python\n@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n\"\"\"Process multiple files in batches\"\"\"\ntry:\nwith open('config/settings.yaml', 'r') as f:\nconfig = yaml.safe_load(f)\nprocessor = BatchProcessor(config)\nfiles = list(Path(directory).rglob('*.py'))\nif priority:\nfiles = processor.prioritize_files(files, priority)\nresults = asyncio.run(processor.process_batch(files, batch_size))\nfor result in results:\nif result['status'] == 'success':\nclick.echo(f'\\nProcessed {result['file']}:')\nclick.echo(format_result(result['analysis']))\nelse:\nclick.echo(f'\\nError processing {result['file']}: {result['error']}')\nexcept Exception as e:\nlogger.error(f'Batch processing error: {e}')\nclick.echo(f'Error: {e}', err=True)\nraise click.Abort()\n```\n",
          "improved": "```python\n@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n\"\"\"Process multiple files in batches\"\"\"\ntry:\nconfig = load_config('config/settings.yaml')\nprocessor = BatchProcessor(config)\nfiles = get_python_files(directory)\nif priority:\nfiles = prioritize_files(processor, files, priority)\nresults = process_batch(processor, files, batch_size)\ndisplay_batch_results(results)\nexcept Exception as e:\nhandle_error(e, 'Batch processing error')\n\ndef load_config(config_path: str) -> dict:\nwith open(config_path, 'r') as f:\nreturn yaml.safe_load(f)\n\ndef get_python_files(directory: str) -> list[Path]:\nreturn list(Path(directory).rglob('*.py'))\n\ndef prioritize_files(processor: BatchProcessor, files: list[Path], priority: str) -> list[Path]:\nreturn processor.prioritize_files(files, priority)\n\ndef process_batch(processor: BatchProcessor, files: list[Path], batch_size: int) -> list[dict]:\nreturn asyncio.run(processor.process_batch(files, batch_size))\n\ndef display_batch_results(results: list[dict]):\nfor result in results:\nif result['status'] == 'success':\nclick.echo(f'\\nProcessed {result['file']}:')\nclick.echo(format_result(result['analysis']))\nelse:\nclick.echo(f'\\nError processing {result['file']}: {result['error']}')\n\ndef handle_error(e: Exception, error_message: str):\nlogger.error(f'{error_message}: {e}')\nclick.echo(f'Error: {e}', err=True)\nraise click.Abort()\n```\n\nThese improvements separate the responsibilities of the `improve` and `batch` functions into smaller, more focused functions, reducing complexity and improving maintainability. The `batch` function is also refactored to reduce nesting and improve readability.\n"
        }
      ]
    }
  ]
}