{
  "timestamp": "20241229_133255",
  "files_analyzed": 1,
  "files_improved": 1,
  "improvements": [
    {
      "file": "src\\cli.py",
      "issues": [
        {
          "type": "length",
          "message": "Function improve is too long (21 lines)",
          "line": 21,
          "function": "improve",
          "original": "@cli.command()\n@click.argument('file_path', type=click.Path(exists=True))\n@click.option('--config', '-c', type=click.Path(exists=True), default='config/settings.yaml', help='Path to config file')\n@click.option('--output', '-o', type=click.Path(), help='Path to save improvements (default: print to console)')\ndef improve(file_path: str, config: str, output: Optional[str]):\n    \"\"\"Analyze and improve the given Python file\"\"\"\n    try:\n        with open(config, 'r') as f:\n            config_data = yaml.safe_load(f)\n        auto_coder = AutoCoder(config_data)\n        result = asyncio.run(auto_coder.improve_code(Path(file_path)))\n        output_text = format_result(result)\n        if output:\n            Path(output).write_text(output_text)\n            click.echo(f'Improvements saved to {output}')\n        else:\n            click.echo(output_text)\n    except Exception as e:\n        logger.error(f'Error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        },
        {
          "type": "length",
          "message": "Function batch is too long (24 lines)",
          "line": 67,
          "function": "batch",
          "original": "@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        },
        {
          "type": "complexity",
          "message": "Function batch has high complexity (6)",
          "line": 67,
          "function": "batch",
          "original": "@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        },
        {
          "type": "nesting",
          "message": "Function batch has deep nesting (depth: 3)",
          "line": 67,
          "function": "batch",
          "original": "@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()"
        }
      ],
      "improvements": [
        {
          "type": "maintainability",
          "description": "The `improve` function is too long and can be split into smaller, more focused functions for better readability and maintainability.",
          "original": "```python\n@cli.command()\n@click.argument('file_path', type=click.Path(exists=True))\n@click.option('--config', '-c', type=click.Path(exists=True), default='config/settings.yaml', help='Path to config file')\n@click.option('--output', '-o', type=click.Path(), help='Path to save improvements (default: print to console)')\ndef improve(file_path: str, config: str, output: Optional[str]):\n    \"\"\"Analyze and improve the given Python file\"\"\"\n    try:\n        with open(config, 'r') as f:\n            config_data = yaml.safe_load(f)\n        auto_coder = AutoCoder(config_data)\n        result = asyncio.run(auto_coder.improve_code(Path(file_path)))\n        output_text = format_result(result)\n        if output:\n            Path(output).write_text(output_text)\n            click.echo(f'Improvements saved to {output}')\n        else:\n            click.echo(output_text)\n    except Exception as e:\n        logger.error(f'Error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()\n```",
          "improved": "```python\n@cli.command()\n@click.argument('file_path', type=click.Path(exists=True))\n@click.option('--config', '-c', type=click.Path(exists=True), default='config/settings.yaml', help='Path to config file')\n@click.option('--output', '-o', type=click.Path(), help='Path to save improvements (default: print to console)')\ndef improve(file_path: str, config: str, output: Optional[str]):\n    \"\"\"Analyze and improve the given Python file\"\"\"\n    try:\n        config_data = load_config(config)\n        auto_coder = AutoCoder(config_data)\n        result = asyncio.run(auto_coder.improve_code(Path(file_path)))\n        output_text = format_result(result)\n        handle_output(output, output_text)\n    except Exception as e:\n        handle_exception(e)\ndef load_config(config_path: str) -> dict:\n    with open(config_path, 'r') as f:\n        return yaml.safe_load(f)\ndef handle_output(output_path: Optional[str], output_text: str):\n    if output_path:\n        Path(output_path).write_text(output_text)\n        click.echo(f'Improvements saved to {output_path}')\n    else:\n        click.echo(output_text)\ndef handle_exception(e: Exception):\n    logger.error(f'Error: {e}')\n    click.echo(f'Error: {e}', err=True)\n    raise click.Abort()\n```"
        },
        {
          "type": "maintainability",
          "description": "The `batch` function is too long and has high complexity. It can be split into smaller, more focused functions for better readability and maintainability.",
          "original": "```python\n@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        with open('config/settings.yaml', 'r') as f:\n            config = yaml.safe_load(f)\n        processor = BatchProcessor(config)\n        files = list(Path(directory).rglob('*.py'))\n        if priority:\n            files = processor.prioritize_files(files, priority)\n        results = asyncio.run(processor.process_batch(files, batch_size))\n        for result in results:\n            if result['status'] == 'success':\n                click.echo(f'\\nProcessed {result['file']}:')\n                click.echo(format_result(result['analysis']))\n            else:\n                click.echo(f'\\nError processing {result['file']}: {result['error']}')\n    except Exception as e:\n        logger.error(f'Batch processing error: {e}')\n        click.echo(f'Error: {e}', err=True)\n        raise click.Abort()\n```",
          "improved": "```python\n@cli.command()\n@click.argument('directory', type=click.Path(exists=True))\n@click.option('--batch-size', '-b', default=5, help='Number of files to process in parallel')\n@click.option('--priority', '-p', type=click.Choice(['size', 'complexity', 'issues']), help='How to prioritize files')\ndef batch(directory: str, batch_size: int, priority: str):\n    \"\"\"Process multiple files in batches\"\"\"\n    try:\n        config = load_config('config/settings.yaml')\n        processor = BatchProcessor(config)\n        files = get_python_files(directory)\n        if priority:\n            files = prioritize_files(processor, files, priority)\n        results = asyncio.run(process_batch(processor, files, batch_size))\n        display_batch_results(results)\n    except Exception as e:\n        handle_exception(e, 'Batch processing error')\ndef get_python_files(directory: str) -> List[Path]:\n    return list(Path(directory).rglob('*.py'))\ndef prioritize_files(processor: BatchProcessor, files: List[Path], priority: str) -> List[Path]:\n    return processor.prioritize_files(files, priority)\ndef process_batch(processor: BatchProcessor, files: List[Path], batch_size: int) -> List[dict]:\n    return processor.process_batch(files, batch_size)\ndef display_batch_results(results: List[dict]):\n    for result in results:\n        if result['status'] == 'success':\n            click.echo(f'\\nProcessed {result['file']}:')\n            click.echo(format_result(result['analysis']))\n        else:\n            click.echo(f'\\nError processing {result['file']}: {result['error']}')\ndef handle_exception(e: Exception, context: str):\n    logger.error(f'{context}: {e}')\n    click.echo(f'Error: {e}', err=True)\n    raise click.Abort()\n```"
        }
      ]
    }
  ]
}